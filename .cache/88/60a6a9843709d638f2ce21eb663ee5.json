{"id":"../node_modules/@tonaljs/tonal/dist/index.esnext.js","dependencies":[{"name":"/Users/musicandcoding/Documents/Projects/chordstuff/node_modules/@tonaljs/tonal/dist/index.esnext.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/musicandcoding/Documents/Projects/chordstuff/package.json","includedInParent":true,"mtime":1582711025140},{"name":"/Users/musicandcoding/Documents/Projects/chordstuff/node_modules/@tonaljs/tonal/package.json","includedInParent":true,"mtime":1578127002584}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coordToInterval = coordToInterval;\nexports.coordToNote = coordToNote;\nexports.decode = decode;\nexports.distance = distance;\nexports.encode = encode;\nexports.interval = interval;\nexports.isNamed = isNamed;\nexports.isPitch = isPitch;\nexports.note = note;\nexports.tokenizeInterval = tokenize$1;\nexports.tokenizeNote = tokenize;\nexports.transpose = transpose;\nexports.altToAcc = exports.accToAlt = void 0;\n\nfunction isNamed(src) {\n  return typeof src === \"object\" && typeof src.name === \"string\";\n}\n\nfunction isPitch(pitch) {\n  return typeof pitch === \"object\" && typeof pitch.step === \"number\" && typeof pitch.alt === \"number\";\n} // The nuuber of fifths of [C, D, E, F, G, A, B]\n\n\nconst FIFTHS = [0, 2, 4, -1, 1, 3, 5]; // The number of octaves it span each step\n\nconst STEPS_TO_OCTS = FIFTHS.map(fifths => Math.floor(fifths * 7 / 12));\n\nfunction encode(pitch) {\n  const {\n    step,\n    alt,\n    oct,\n    dir = 1\n  } = pitch;\n  const f = FIFTHS[step] + 7 * alt;\n\n  if (oct === undefined) {\n    return [dir * f];\n  }\n\n  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n} // We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for [\"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\"] we have:\n\n\nconst FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];\n\nfunction decode(coord) {\n  const [f, o, dir] = coord;\n  const step = FIFTHS_TO_STEPS[unaltered(f)];\n  const alt = Math.floor((f + 1) / 7);\n\n  if (o === undefined) {\n    return {\n      step,\n      alt,\n      dir\n    };\n  }\n\n  const oct = o + 4 * alt + STEPS_TO_OCTS[step];\n  return {\n    step,\n    alt,\n    oct,\n    dir\n  };\n} // Return the number of fifths as if it were unaltered\n\n\nfunction unaltered(f) {\n  const i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n\nconst NoNote = {\n  empty: true,\n  name: \"\",\n  pc: \"\",\n  acc: \"\"\n};\nconst cache = {};\n\nconst fillStr = (s, n) => Array(n + 1).join(s);\n\nconst stepToLetter = step => \"CDEFGAB\".charAt(step);\n\nconst altToAcc = alt => alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt);\n\nexports.altToAcc = altToAcc;\n\nconst accToAlt = acc => acc[0] === \"b\" ? -acc.length : acc.length;\n/**\r\n * Given a note literal (a note name or a note object), returns the Note object\r\n * @example\r\n * note('Bb4') // => { name: \"Bb4\", midi: 70, chroma: 10, ... }\r\n */\n\n\nexports.accToAlt = accToAlt;\n\nfunction note(src) {\n  return typeof src === \"string\" ? cache[src] || (cache[src] = parse(src)) : isPitch(src) ? note(pitchName(src)) : isNamed(src) ? note(src.name) : NoNote;\n}\n\nconst REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/;\n/**\r\n * @private\r\n */\n\nfunction tokenize(str) {\n  const m = REGEX.exec(str);\n  return [m[1].toUpperCase(), m[2].replace(/x/g, \"##\"), m[3], m[4]];\n}\n/**\r\n * @private\r\n */\n\n\nfunction coordToNote(noteCoord) {\n  return note(decode(noteCoord));\n}\n\nconst SEMI = [0, 2, 4, 5, 7, 9, 11];\n\nfunction parse(noteName) {\n  const tokens = tokenize(noteName);\n\n  if (tokens[0] === \"\" || tokens[3] !== \"\") {\n    return NoNote;\n  }\n\n  const letter = tokens[0];\n  const acc = tokens[1];\n  const octStr = tokens[2];\n  const step = (letter.charCodeAt(0) + 3) % 7;\n  const alt = accToAlt(acc);\n  const oct = octStr.length ? +octStr : undefined;\n  const coord = encode({\n    step,\n    alt,\n    oct\n  });\n  const name = letter + acc + octStr;\n  const pc = letter + acc;\n  const chroma = (SEMI[step] + alt + 120) % 12;\n  const o = oct === undefined ? -100 : oct;\n  const height = SEMI[step] + alt + 12 * (o + 1);\n  const midi = height >= 0 && height <= 127 ? height : null;\n  const freq = oct === undefined ? null : Math.pow(2, (height - 69) / 12) * 440;\n  return {\n    empty: false,\n    acc,\n    alt,\n    chroma,\n    coord,\n    freq,\n    height,\n    letter,\n    midi,\n    name,\n    oct,\n    pc,\n    step\n  };\n}\n\nfunction pitchName(props) {\n  const {\n    step,\n    alt,\n    oct\n  } = props;\n  const letter = stepToLetter(step);\n\n  if (!letter) {\n    return \"\";\n  }\n\n  const pc = letter + altToAcc(alt);\n  return oct || oct === 0 ? pc + oct : pc;\n}\n\nconst NoInterval = {\n  empty: true,\n  name: \"\",\n  acc: \"\"\n}; // shorthand tonal notation (with quality after number)\n\nconst INTERVAL_TONAL_REGEX = \"([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})\"; // standard shorthand notation (with quality before number)\n\nconst INTERVAL_SHORTHAND_REGEX = \"(AA|A|P|M|m|d|dd)([-+]?\\\\d+)\";\nconst REGEX$1 = new RegExp(\"^\" + INTERVAL_TONAL_REGEX + \"|\" + INTERVAL_SHORTHAND_REGEX + \"$\");\n/**\r\n * @private\r\n */\n\nfunction tokenize$1(str) {\n  const m = REGEX$1.exec(`${str}`);\n\n  if (m === null) {\n    return [\"\", \"\"];\n  }\n\n  return m[1] ? [m[1], m[2]] : [m[4], m[3]];\n}\n\nconst cache$1 = {};\n/**\r\n * Get interval properties. It returns an object with:\r\n *\r\n * - name: the interval name\r\n * - num: the interval number\r\n * - type: 'perfectable' or 'majorable'\r\n * - q: the interval quality (d, m, M, A)\r\n * - dir: interval direction (1 ascending, -1 descending)\r\n * - simple: the simplified number\r\n * - semitones: the size in semitones\r\n * - chroma: the interval chroma\r\n *\r\n * @param {string} interval - the interval name\r\n * @return {Object} the interval properties\r\n *\r\n * @example\r\n * import { interval } from '@tonaljs/tonal'\r\n * interval('P5').semitones // => 7\r\n * interval('m3').type // => 'majorable'\r\n */\n\nfunction interval(src) {\n  return typeof src === \"string\" ? cache$1[src] || (cache$1[src] = parse$1(src)) : isPitch(src) ? interval(pitchName$1(src)) : isNamed(src) ? interval(src.name) : NoInterval;\n}\n\nconst SIZES = [0, 2, 4, 5, 7, 9, 11];\nconst TYPES = \"PMMPPMM\";\n\nfunction parse$1(str) {\n  const tokens = tokenize$1(str);\n\n  if (tokens[0] === \"\") {\n    return NoInterval;\n  }\n\n  const num = +tokens[0];\n  const q = tokens[1];\n  const step = (Math.abs(num) - 1) % 7;\n  const t = TYPES[step];\n\n  if (t === \"M\" && q === \"P\") {\n    return NoInterval;\n  }\n\n  const type = t === \"M\" ? \"majorable\" : \"perfectable\";\n  const name = \"\" + num + q;\n  const dir = num < 0 ? -1 : 1;\n  const simple = num === 8 || num === -8 ? num : dir * (step + 1);\n  const alt = qToAlt(type, q);\n  const oct = Math.floor((Math.abs(num) - 1) / 7);\n  const semitones = dir * (SIZES[step] + alt + 12 * oct);\n  const chroma = (dir * (SIZES[step] + alt) % 12 + 12) % 12;\n  const coord = encode({\n    step,\n    alt,\n    oct,\n    dir\n  });\n  return {\n    empty: false,\n    name,\n    num,\n    q,\n    step,\n    alt,\n    dir,\n    type,\n    simple,\n    semitones,\n    chroma,\n    coord,\n    oct\n  };\n}\n/**\r\n * @private\r\n */\n\n\nfunction coordToInterval(coord) {\n  const [f, o = 0] = coord;\n  const isDescending = f * 7 + o * 12 < 0;\n  const ivl = isDescending ? [-f, -o, -1] : [f, o, 1];\n  return interval(decode(ivl));\n}\n\nfunction qToAlt(type, q) {\n  return q === \"M\" && type === \"majorable\" || q === \"P\" && type === \"perfectable\" ? 0 : q === \"m\" && type === \"majorable\" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === \"perfectable\" ? q.length : q.length + 1) : 0;\n} // return the interval name of a pitch\n\n\nfunction pitchName$1(props) {\n  const {\n    step,\n    alt,\n    oct = 0,\n    dir\n  } = props;\n\n  if (!dir) {\n    return \"\";\n  }\n\n  const num = step + 1 + 7 * oct;\n  const d = dir < 0 ? \"-\" : \"\";\n  const type = TYPES[step] === \"M\" ? \"majorable\" : \"perfectable\";\n  const name = d + num + altToQ(type, alt);\n  return name;\n}\n\nconst fillStr$1 = (s, n) => Array(Math.abs(n) + 1).join(s);\n\nfunction altToQ(type, alt) {\n  if (alt === 0) {\n    return type === \"majorable\" ? \"M\" : \"P\";\n  } else if (alt === -1 && type === \"majorable\") {\n    return \"m\";\n  } else if (alt > 0) {\n    return fillStr$1(\"A\", alt);\n  } else {\n    return fillStr$1(\"d\", type === \"perfectable\" ? alt : alt + 1);\n  }\n}\n/**\r\n * Transpose a note by an interval.\r\n *\r\n * @param {string} note - the note or note name\r\n * @param {string} interval - the interval or interval name\r\n * @return {string} the transposed note name or empty string if not valid notes\r\n * @example\r\n * import { tranpose } from \"@tonaljs/tonal\"\r\n * transpose(\"d3\", \"3M\") // => \"F#3\"\r\n * transpose(\"D\", \"3M\") // => \"F#\"\r\n * [\"C\", \"D\", \"E\", \"F\", \"G\"].map(pc => transpose(pc, \"M3)) // => [\"E\", \"F#\", \"G#\", \"A\", \"B\"]\r\n */\n\n\nfunction transpose(noteName, intervalName) {\n  const note$1 = note(noteName);\n  const interval$1 = interval(intervalName);\n\n  if (note$1.empty || interval$1.empty) {\n    return \"\";\n  }\n\n  const noteCoord = note$1.coord;\n  const intervalCoord = interval$1.coord;\n  const tr = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];\n  return coordToNote(tr).name;\n}\n/**\r\n * Find the interval distance between two notes or coord classes.\r\n *\r\n * To find distance between coord classes, both notes must be coord classes and\r\n * the interval is always ascending\r\n *\r\n * @param {Note|string} from - the note or note name to calculate distance from\r\n * @param {Note|string} to - the note or note name to calculate distance to\r\n * @return {string} the interval name or empty string if not valid notes\r\n *\r\n */\n\n\nfunction distance(fromNote, toNote) {\n  const from = note(fromNote);\n  const to = note(toNote);\n\n  if (from.empty || to.empty) {\n    return \"\";\n  }\n\n  const fcoord = from.coord;\n  const tcoord = to.coord;\n  const fifths = tcoord[0] - fcoord[0];\n  const octs = fcoord.length === 2 && tcoord.length === 2 ? tcoord[1] - fcoord[1] : -Math.floor(fifths * 7 / 12);\n  return coordToInterval([fifths, octs]).name;\n}"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"df464151f5657e28a2549537d115fd13","cacheData":{"env":{}}}